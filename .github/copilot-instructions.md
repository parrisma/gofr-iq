# GOFR-IQ Copilot Instructions

## Core Rules
- **Runs in a dev container** and has Docker access.
- **Never use `localhost`**; use service hostnames (e.g., `gofr-neo4j`, `gofr-chromadb`, `gofr-vault`).
- **Always prefer control scripts** to manage services, auth, ingestion, and tests.
- This repo is part of the **GOFR suite** and uses **gofr-common** for shared config/auth/scripts.
- **Keep code simple.**
- **When debugging, check basics first** (env, health, logs, auth, connectivity) to avoid spinning.
- **Run commands so the user can read and help**; avoid hiding output with `head`, `tail`, or heavy filtering.
- **If the user reminds a preferred behavior, suggest updating this file** to make it permanent.
- **For large changes**, follow this workflow:
	1. Write a short **spec document**.
	2. **Peer review** the spec to simplify/refine the design.
	3. Write a **small-step implementation plan** with checkboxes and tests (tests pass before start, pass after finish; update at each step).
	4. **Peer review** the implementation plan to simplify/refine.
	5. Do a **post-review** of code from functional and technical perspectives to ensure it matches the spec and is simple, clean, and robust.

## Start/Stop (use scripts)
**ALWAYS use `./scripts/start-prod.sh`** to start/restart gofr-iq services. Never use `docker compose` directly - the start script handles Vault secrets, AppRole credentials, environment loading, and proper service ordering.

```bash
./scripts/start-prod.sh          # Start/restart prod stack (use this for ANY service restart)
./scripts/start-prod.sh --fresh  # First-time setup
./scripts/start-prod.sh --nuke   # Full clean: remove images, volumes, then rebuild
./docker/start-tools-prod.sh     # n8n + OpenWebUI
./scripts/run_tests.sh           # Run tests
```

## Authentication & Permissions (CRITICAL - READ FIRST)

### Secret Locations (all under `secrets/` symlinked to `lib/gofr-common/secrets/`)
- **Vault root token**: `secrets/vault_root_token` (for emergency Vault access)
- **Vault unseal key**: `secrets/vault_unseal_key` (auto-unseals on restart)
- **Bootstrap JWT tokens**: `secrets/bootstrap_tokens.json` (admin_token, public_token - 365-day tokens)
- **AppRole credentials**: `secrets/service_creds/{service}_role_id` and `{service}_secret_id` (auto-mounted to containers)
- **Docker env**: `docker/.env` (generated by scripts, contains NEO4J_PASSWORD, VAULT_TOKEN, etc.)

### Getting Credentials (ALWAYS use these methods)

#### 1. JWT Tokens (for MCP/API access)
```bash
# Load admin token into environment (PREFERRED)
source <(./lib/gofr-common/scripts/auth_env.sh --docker)
# Sets: $GOFR_ADMIN_TOKEN, $GOFR_PUBLIC_TOKEN

# Or extract manually
export TOKEN=$(jq -r '.admin_token.token' secrets/bootstrap_tokens.json)
```

#### 2. Neo4j Password (for direct database queries)
```bash
# Method 1: From Vault (SAFEST - no shell escaping issues)
export VAULT_TOKEN=$(cat secrets/vault_root_token)
export NEO4J_PASSWORD=$(docker exec -e VAULT_ADDR=http://gofr-vault:8201 -e VAULT_TOKEN=$VAULT_TOKEN \
  gofr-vault vault kv get -field=value secret/gofr/config/neo4j-password)

# Method 2: From docker/.env (if it exists)
source docker/.env  # Sets NEO4J_PASSWORD

# Method 3: Query inside container (RECOMMENDED - avoids auth issues)
docker exec -e NEO4J_USER=neo4j -e NEO4J_PASSWORD="$NEO4J_PASSWORD" gofr-iq-mcp \
  python3 -c "from neo4j import GraphDatabase; ..."
```

#### 3. Vault Access (for managing secrets)
```bash
export VAULT_TOKEN=$(cat secrets/vault_root_token)
export VAULT_ADDR=http://gofr-vault:8201  # or localhost:8201 if on host
# Then use vault CLI or docker exec
docker exec -e VAULT_ADDR=$VAULT_ADDR -e VAULT_TOKEN=$VAULT_TOKEN \
  gofr-vault vault kv get secret/gofr/config/neo4j-password
```

### Auth Management (use gofr-common scripts)
```bash
source <(./lib/gofr-common/scripts/auth_env.sh --docker)
./lib/gofr-common/scripts/auth_manager.sh --docker groups list
./lib/gofr-common/scripts/auth_manager.sh --docker tokens list
./lib/gofr-common/scripts/auth_manager.sh --docker tokens create --groups GROUP --name NAME
```

### Group/Permission Model (IMPORTANT for client queries)
- **All Client nodes MUST have `IN_GROUP` relationship** to appear in `list_clients` queries
- **Admin token** should have access to all groups via `resolve_permitted_groups(admin_token)`
- **Query filter**: `MATCH (c:Client)-[:IN_GROUP]->(g:Group) WHERE g.guid IN $group_guids`
- **Debug access**: Check groups with `auth_manager.sh --docker groups list`

### Safe Database Querying (avoid password escaping issues)

#### ❌ DON'T (shell escaping causes auth failures)
```bash
# BAD - password may have special chars
docker exec gofr-neo4j cypher-shell -u neo4j -p "$NEO4J_PASSWORD" "MATCH (n) RETURN n"
# BAD - heredoc variable scoping issues
python3 << 'EOF'
password = os.environ.get("NEO4J_PASSWORD")  # Not available in heredoc
EOF
```

#### ✅ DO (safe methods)
```bash
# GOOD - Query inside app container (already authenticated)
docker exec gofr-iq-mcp python3 -c "
from app.services.neo4j_service import Neo4jService
from app.config import settings
with Neo4jService(settings) as neo4j:
    result = neo4j.run_query('MATCH (n) RETURN labels(n) as label, count(n) as count')
    for record in result:
        print(f'{record[\"label\"]}: {record[\"count\"]}')
"

# GOOD - Use Python with proper env var handling
export NEO4J_PASSWORD=$(docker exec -e VAULT_TOKEN=$(cat secrets/vault_root_token) \
  gofr-vault vault kv get -field=value secret/gofr/config/neo4j-password)
uv run python3 -c "
import os
from neo4j import GraphDatabase
driver = GraphDatabase.driver('bolt://gofr-neo4j:7687', 
                               auth=('neo4j', os.environ['NEO4J_PASSWORD']))
with driver.session() as session:
    result = session.run('MATCH (n) RETURN labels(n) as label, count(n) as count')
    for record in result:
        print(f'{record[\"label\"]}: {record[\"count\"]}')
driver.close()
"
```

## Documents (use scripts)
```bash
./scripts/manage_document.sh ingest --source-guid UUID --title "..." --content "..." --token $TOKEN
./scripts/manage_document.sh query --query "search" --token $TOKEN
./scripts/manage_source.sh list
```

## Clients (use scripts)
```bash
./scripts/manage_client.sh --docker --token $TOKEN <command> [args]
# Manage clients via MCP (create, list, get, update, delete, defunct, restore, add-holding, add-watch, validate)
# Use --help for full usage
```

## Simulation
```bash
uv run simulation/run_simulation.py --count 50
```

## Logging
- Use the **project logger** (e.g., `StructuredLogger`), **not** `print()` or default logging.
- Logs must be **clear and actionable**, not cryptic.
- All errors must include **cause, references/context**, and **recovery options** where possible.

## Testing
- **Always run `./scripts/run_tests.sh` to verify each step**, and report failures with recovery options.
- **Test fixtures that create services with explicit settings bypass env vars.** If a fixture does `LLMSettings(api_key=key)` without other params, it uses class defaults, not `os.environ`. Always read env vars explicitly in fixtures.
- **Deterministic embeddings**: Mock mode uses hash-based embeddings (384 dim) that produce consistent but **not semantically meaningful** vectors. Tests checking semantic similarity must either:
  1. Skip the assertion in mock mode (`if live_llm_available()`)
  2. Use membership assertions instead of ordering (document in results, not results[0])
  3. Only verify query mechanics work (no errors, response not None)
